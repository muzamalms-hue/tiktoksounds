<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sound Button App — Dial Pad PWA</title>

<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#2563eb">

<style>
  :root{
    --btn-size: 84px;
    --btn-gap: 12px;
    --btn-font: 22px;
  }
  body{
    margin:0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", Arial;
    background:#f3f4f6;
    color:#111827;
    padding:18px;
    -webkit-tap-highlight-color: transparent;
  }
  header{
    text-align:center;
    margin-bottom:12px;
  }
  h1{ margin:6px 0; font-size:20px; }
  p.small{ margin:0; color:#6b7280; font-size:13px; }

  #buttonArea{
    display:grid;
    grid-template-columns: repeat(3, var(--btn-size));
    gap: var(--btn-gap);
    justify-content:center;
    align-items:center;
    padding:10px;
    margin: 8px auto;
  }

  .dial-btn{
    width:var(--btn-size);
    height:var(--btn-size);
    border-radius:50%;
    border:none;
    background: linear-gradient(180deg,#3b82f6,#2563eb);
    color:white;
    font-size:var(--btn-font);
    display:inline-flex;
    justify-content:center;
    align-items:center;
    box-shadow: 0 6px 14px rgba(16,24,40,0.08);
    user-select:none;
    -webkit-user-select:none;
    touch-action: manipulation;
    transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s;
    position:relative;
  }
  .dial-btn:active{
    transform: translateY(2px) scale(0.99);
    box-shadow: 0 3px 8px rgba(16,24,40,0.12);
    filter: brightness(0.98);
  }

  .remove-x{
    position:absolute;
    top:-8px;
    right:-8px;
    width:22px;
    height:22px;
    background:#ef4444;
    color:white;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    border:2px solid white;
    cursor:pointer;
    box-shadow:0 4px 8px rgba(0,0,0,0.12);
  }

  #controls{
    max-width:640px;
    margin: 14px auto;
    background:white;
    padding:12px;
    border-radius:10px;
    box-shadow: 0 6px 18px rgba(15,23,42,0.04);
  }
  .row{ display:flex; gap:8px; align-items:center; margin-bottom:8px; }
  input[type="text"]{ flex:1; padding:10px; border-radius:8px; border:1px solid #e5e7eb; font-size:14px; }
  input[type="file"]{ flex:1; }
  .add-btn{
    background:#10b981;
    color:white;
    border:none;
    padding:10px 14px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
  }
  .hint{ font-size:13px; color:#6b7280; margin-top:6px; }

  .footer{
    max-width:640px;
    margin: 8px auto;
    font-size:13px;
    color:#6b7280;
    text-align:center;
  }

  @media (max-width:420px){
    :root{ --btn-size:68px; --btn-font:20px; --btn-gap:10px; }
  }
</style>
</head>
<body>
<header>
  <h1>Sound Button App — Dial Pad PWA</h1>
  <p class="small">Buttons are round and dial-pad sized. Add sounds — they are saved locally and available offline.</p>
</header>

<div id="buttonArea" aria-live="polite"></div>

<section id="controls" aria-label="Add new sound button">
  <div class="row">
    <input id="btnText" type="text" placeholder="Button label (e.g. 1, A, Clap)" />
    <input id="btnSound" type="file" accept="audio/*" />
    <button id="add" class="add-btn">Add & Save</button>
  </div>
  <div class="hint">Auto-save: once you add, the button is stored locally and will persist across app restarts.</div>
  <div style="font-size:13px; color:#6b7280; margin-top:8px;">
    <strong>How to remove:</strong> tap the small red × on a button to delete it.
  </div>
</section>

<div class="footer">Tip: Install this app to your device (Add to Home Screen) for native-like experience.</div>

<script>
/*
  Features implemented:
  - Uses IndexedDB to store buttons with audio ArrayBuffer -> persistent across sessions and available offline.
  - Decodes audio with Web Audio API for low-latency playback (AudioBuffer in memory after load).
  - Buttons can be removed; add button auto-saves to DB (so you don't re-add each time).
  - PWA ready: manifest + service worker (registers /sw.js) for offline app shell caching.
*/

const DB_NAME = 'sound-buttons-db';
const DB_STORE = 'buttons';
let db = null;
let audioCtx = null;
const buttonArea = document.getElementById('buttonArea');
const addBtn = document.getElementById('add');
const textInput = document.getElementById('btnText');
const fileInput = document.getElementById('btnSound');

// In-memory list: {id, label, buffer, arrayBuffer (optional), mime}
let buttons = [];

/* ----- IndexedDB helpers ----- */
function openDb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e) => {
      const idb = e.target.result;
      if (!idb.objectStoreNames.contains(DB_STORE)) {
        idb.createObjectStore(DB_STORE, { keyPath: 'id' }); // id, label, arrayBuffer, mime
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e.target.error);
  });
}

function idbPut(obj) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction([DB_STORE], 'readwrite');
    const store = tx.objectStore(DB_STORE);
    const r = store.put(obj);
    r.onsuccess = ()=> resolve(r.result);
    r.onerror = (e) => reject(e.target.error);
  });
}

function idbGetAll() {
  return new Promise((resolve, reject) => {
    const tx = db.transaction([DB_STORE], 'readonly');
    const store = tx.objectStore(DB_STORE);
    const r = store.getAll();
    r.onsuccess = ()=> resolve(r.result);
    r.onerror = (e) => reject(e.target.error);
  });
}

function idbDelete(id) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction([DB_STORE], 'readwrite');
    const store = tx.objectStore(DB_STORE);
    const r = store.delete(id);
    r.onsuccess = ()=> resolve();
    r.onerror = (e) => reject(e.target.error);
  });
}

/* ----- Audio helpers ----- */
function ensureAudioContext(){
  if (!audioCtx) {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return null;
      audioCtx = new AC();
    } catch (e) {
      audioCtx = null;
    }
  }
  return audioCtx;
}

async function decodeArrayBuffer(arrayBuffer) {
  const AC = ensureAudioContext();
  if (!AC) return null;
  try {
    // Need to use a copy of buffer in some browsers
    return await AC.decodeAudioData(arrayBuffer.slice(0));
  } catch (e) {
    // Some browsers need older callback-based decodeAudioData
    return new Promise((res, rej) => {
      AC.decodeAudioData(arrayBuffer.slice(0), (decoded) => res(decoded), (err) => rej(err));
    });
  }
}

function playFromBuffer(btn) {
  if (btn.buffer && audioCtx) {
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const src = audioCtx.createBufferSource();
    src.buffer = btn.buffer;
    src.connect(audioCtx.destination);
    try {
      src.start(0);
    } catch (e) {
      // older browsers might require small time offset
      src.start(audioCtx.currentTime + 0.001);
    }
  } else if (btn.arrayBuffer) {
    // fallback: create blob URL
    const blob = new Blob([btn.arrayBuffer], { type: btn.mime || 'audio/*' });
    const url = URL.createObjectURL(blob);
    const a = new Audio(url);
    a.play().catch(()=>{});
    // revoke after playing a bit
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  } else {
    console.warn('No audio available for', btn);
  }
}

/* ----- UI / data flow ----- */
function createButtonElement(btn) {
  const el = document.createElement('button');
  el.className = 'dial-btn';
  el.type = 'button';
  el.setAttribute('aria-label', 'Play ' + btn.label);
  el.textContent = btn.label;

  const remove = document.createElement('div');
  remove.className = 'remove-x';
  remove.title = 'Remove';
  remove.textContent = '×';

  remove.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (!confirm('Remove button "' + btn.label + '"?')) return;
    await idbDelete(btn.id);
    buttons = buttons.filter(b => b.id !== btn.id);
    renderButtons();
  });

  el.addEventListener('pointerdown', (e) => { e.preventDefault(); playFromBuffer(btn); });
  el.addEventListener('click', (e)=>{ e.preventDefault(); playFromBuffer(btn); });

  el.appendChild(remove);
  return el;
}

function renderButtons() {
  buttonArea.innerHTML = '';
  buttons.forEach(b => {
    const el = createButtonElement(b);
    buttonArea.appendChild(el);
  });
}

async function loadFromDb() {
  await openDb();
  const all = await idbGetAll();
  // each item: {id, label, arrayBuffer, mime}
  const AC = ensureAudioContext();
  buttons = [];
  for (const it of all) {
    let buffer = null;
    if (it.arrayBuffer && AC) {
      try {
        buffer = await decodeArrayBuffer(it.arrayBuffer);
      } catch (e) {
        console.warn('Decode failed for', it.id, e);
        buffer = null;
      }
    }
    buttons.push({ id: it.id, label: it.label, arrayBuffer: it.arrayBuffer, mime: it.mime, buffer });
  }
  renderButtons();
}

/* Add button flow: read file, decode, save arrayBuffer to idb, push to in-memory */
async function addButton() {
  const label = textInput.value.trim() || 'Btn';
  const file = fileInput.files[0];
  if (!file) {
    alert('Please select an audio file.');
    return;
  }
  const id = Date.now().toString(36) + Math.random().toString(36).slice(2,6);
  const mime = file.type || 'audio/*';
  const arrayBuffer = await file.arrayBuffer();

  const AC = ensureAudioContext();
  let buffer = null;
  if (AC) {
    try {
      buffer = await decodeArrayBuffer(arrayBuffer);
    } catch (e){
      console.warn('decode failed, will store raw', e);
    }
  }

  // save to IDB (store arrayBuffer)
  const obj = { id, label, arrayBuffer, mime };
  await openDb();
  await idbPut(obj);

  // add to in-memory and render
  buttons.push({ id, label, arrayBuffer, mime, buffer });
  textInput.value = '';
  fileInput.value = '';
  renderButtons();
}

/* Initialization */
(async function init(){
  // register service worker for PWA
  if ('serviceWorker' in navigator) {
    try {
      await navigator.serviceWorker.register('/sw.js');
      console.log('Service worker registered');
    } catch (e) {
      console.warn('SW register failed', e);
    }
  }
  // load from IndexedDB
  try {
    await loadFromDb();
  } catch (e) {
    console.error('DB load failed', e);
  }

  // hook events
  addBtn.addEventListener('click', addButton);
  textInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      if (fileInput.files.length) addButton();
      else fileInput.focus();
    }
  });
})();

</script>
</body>
</html>
